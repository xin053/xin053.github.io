<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="jFTy9MrTO4piYCnfdfFFpOLb9SCydVuSBPbqgakCzCM">










  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Git,">





  <link rel="alternate" href="/atom.xml" title="xin053" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1">






<meta name="description" content="git介绍git为分布式版本控制系统，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。  Git 不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一">
<meta name="keywords" content="Git">
<meta property="og:type" content="article">
<meta property="og:title" content="Git使用详解">
<meta property="og:url" content="https://xin053.github.io/2016/06/18/Git使用详解/index.html">
<meta property="og:site_name" content="xin053">
<meta property="og:description" content="git介绍git为分布式版本控制系统，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。  Git 不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121202_798.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121204_39.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121205_151.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121432_845.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121719_123.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121721_705.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121722_450.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121722_624.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121723_520.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121724_229.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121724_283.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121725_226.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121725_89.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121726_3.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121726_846.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121727_65.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121727_499.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121728_242.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121729_2.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121729_46.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121730_974.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121731_919.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121732_963.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121733_745.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121734_669.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121735_607.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121736_936.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121737_674.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121738_258.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121738_893.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121739_386.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121739_29.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121740_319.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121740_891.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121741_142.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121742_594.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121743_361.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121743_370.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121744_939.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121745_75.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121746_276.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122033_852.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122034_158.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122035_917.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122035_292.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122035_852.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122036_995.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122037_94.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122037_695.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122038_871.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122038_536.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122039_393.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122039_398.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122040_316.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122041_488.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122041_903.png">
<meta property="og:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201122042_782.png">
<meta property="og:updated_time" content="2017-05-27T13:20:48.767Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git使用详解">
<meta name="twitter:description" content="git介绍git为分布式版本控制系统，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。  Git 不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一">
<meta name="twitter:image" content="http://static.open-open.com/lib/uploadImg/20120201/20120201121202_798.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>

  <title> Git使用详解 | xin053 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-78789863-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?95bc477a974f85651897b76f543028bb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta">
  

  <div class="custom-logo-site-title">
    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">xin053</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">在安全圈里徘徊，停滞不前</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Git使用详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-18T19:58:51+08:00" content="2016-06-18">
              2016-06-18
            </time>
          </span>

          
            <span class="post-category">
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/18/Git使用详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/18/Git使用详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <link rel="stylesheet" type="text/css" href="/assets/css/DPlayer.min.css"><script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2 id="git介绍"><a href="#git介绍" class="headerlink" title="git介绍"></a>git介绍</h2><p>git为分布式版本控制系统，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜 像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121202_798.png" alt=""></p>
<p>Git 不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这次快照 的索引。为提高性能，若文件没有变化，Git 不会再次保存，而只对上次保存的快照作一链接。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121204_39.png" alt=""></p>
<a id="more"></a>
<h2 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h2><p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。</p>
<p>Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121205_151.png" alt=""></p>
<h2 id="文件的两种状态"><a href="#文件的两种状态" class="headerlink" title="文件的两种状态"></a>文件的两种状态</h2><p>工作目录下面的所有文件都不外乎这两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是修改后add但没有commit，修改后没有add,或者没变。而所有其他文件都属于未跟踪文件(即在上次的版本基础上新增的文件，因为需要决定新增的文件是否需要加到gitignore中，所以文件状态为未跟踪，如果add这些文件，那么这些文件的状态就变成已跟踪)。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121432_845.png" alt=""></p>
<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><p>我新建learnGit文件夹，文件夹下就一个空白test1.txt文件，然后git bash切到这个目录，执行<code>git init</code>，初始化仓库，然后执行<code>git add .</code>后执行<code>git status</code>，可以看到以下输出：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line"></div><div class="line">Initial commit</div><div class="line"></div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        new file:   test1.txt</div></pre></td></tr></table></figure>
<p>表示test1.txt是已跟踪文件，并add到了暂存区，等待commit</p>
<p>我们执行<code>git commit -m &#39;first commit&#39;</code>提交暂存区文件。(<code>git commit -am &#39;message&#39;</code>的<code>-am</code>参数是先add所有已修改的文件，然后附加message提交)</p>
<p>再执行<code>git status</code>可以看到：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div></pre></td></tr></table></figure>
<p>然后我们修改test1.txt的内容，在里面添加一些东西，然后再执行<code>git status</code>可以看到：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes not staged <span class="keyword">for</span> commit:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</div><div class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</div><div class="line"></div><div class="line">        modified:   test1.txt</div><div class="line"></div><div class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</div></pre></td></tr></table></figure>
<p>这表示已跟踪的文件被修改了但是没有add，然后我们按照提示执行<code>git add test1.txt</code>,再执行<code>git status</code>，可以看到以下输出：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Changes to be committed:</div><div class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</div><div class="line"></div><div class="line">        modified:   test1.txt</div></pre></td></tr></table></figure>
<p>也就是已跟踪的文件add到了暂存区，但是还没commit。我们执行<code>git commit -m &#39;second commit&#39;</code>再次提交后，在仓库下新建test2.txt空文件，然后执行<code>git status</code>，可以看到以下输出：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line">On branch master</div><div class="line">Untracked files:</div><div class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</div><div class="line"></div><div class="line">        test2.txt</div><div class="line"></div><div class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</div></pre></td></tr></table></figure>
<p>显示test2.txt文件为未跟踪文件，可以使用<code>git add 文件名</code>将该文件变为已跟踪文件，也可以将该文件添加到.gitignore文件中，表示不跟踪此文件，并不再在’Untracked files:’中提醒该未跟踪的文件。</p>
<h2 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h2><p>以一个例子来说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 此为注释 – 将被 Git 忽略</div><div class="line">*.a       # 忽略所有 .a 结尾的文件</div><div class="line">!lib.a    # 但 lib.a 除外</div><div class="line">/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</div><div class="line">build/    # 忽略 build/ 目录下的所有文件</div><div class="line">doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</div></pre></td></tr></table></figure>
<h2 id="差异查看"><a href="#差异查看" class="headerlink" title="差异查看"></a>差异查看</h2><p><code>git diff</code>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/test2.txt b/test2.txt</div><div class="line">index 3b18e51..b4a78f9 100644</div><div class="line"><span class="comment">--- a/test2.txt</span></div><div class="line"><span class="comment">+++ b/test2.txt</span></div><div class="line">@@ -1 +1 @@</div><div class="line"><span class="deletion">-hello world</span></div><div class="line"><span class="addition">+world hello</span></div></pre></td></tr></table></figure>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些。）</p>
<h2 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h2><h3 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h3><p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 <code>--amend</code> 选项重新提交：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure>
<p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p>
<p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 –amend 提交：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'initial commit'</span></div><div class="line">$ git add forgotten_file</div><div class="line">$ git commit --amend</div></pre></td></tr></table></figure>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<h3 id="取消已经暂存的文件"><a href="#取消已经暂存的文件" class="headerlink" title="取消已经暂存的文件"></a>取消已经暂存的文件</h3><p>用<code>git reset HEAD ...</code> 的方式取消暂存，例如：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD test.txt</div></pre></td></tr></table></figure>
<p>这样test.txt又回到了之前已经修改但是还未暂存的状态。</p>
<h3 id="取消对文件的修改"><a href="#取消对文件的修改" class="headerlink" title="取消对文件的修改"></a>取消对文件的修改</h3><p>用<code>git checkout -- test.txt</code>将使text.txt文件回到之前未修改的状态。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>要查看当前配置有哪些远程仓库，可以用<code>git remote</code>命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：</p>
<p>也可以加上<code>-v</code>选项（译注：此为<code>--verbose</code>的简写，取首字母），显示对应的克隆地址：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div><div class="line">origin	git://github.com/xin053/xin053.github.io.git</div></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行<code>git remote add [shortname] [url]</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote add test git://github.com/xin053/xin053.github.io.git</div><div class="line">$ git remote -v</div><div class="line">test	git://github.com/xin053/xin053.github.io.git</div></pre></td></tr></table></figure>
<h3 id="从远程仓库抓取数据"><a href="#从远程仓库抓取数据" class="headerlink" title="从远程仓库抓取数据"></a>从远程仓库抓取数据</h3><p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch [remote-name]</div></pre></td></tr></table></figure>
<p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。</p>
<p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，<code>git fetch origin</code> 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p>
<p>如果设置了某个分支用于<strong>跟踪</strong>某个远端仓库的分支（参见下节及第三章的内容），可以使用<code>git pull</code>命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下<code>git clone</code>命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行<code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
<h3 id="推送数据到远程仓库"><a href="#推送数据到远程仓库" class="headerlink" title="推送数据到远程仓库"></a>推送数据到远程仓库</h3><p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单：<code>git push [remote-name] [branch-name]</code>。如果要把本地的 master 分支推送到origin 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div></pre></td></tr></table></figure>
<p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。<strong>如果在你推数据前，已经有其他人推送了若干更新，那 你的推送操作就会被驳回</strong>。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。</p>
<h3 id="远程仓库的删除和重命名"><a href="#远程仓库的删除和重命名" class="headerlink" title="远程仓库的删除和重命名"></a>远程仓库的删除和重命名</h3><p>在新版 Git 中可以用<code>git remote rename</code>命令修改某个远程仓库在本地的简短名称，比如想把 pb 改成paul，可以这么运行：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git remote rename pb paul</div><div class="line">$ git remote</div><div class="line">origin</div><div class="line">paul</div></pre></td></tr></table></figure>
<p>移除对应的远端仓库，可以运行 <code>git remote rm</code> 命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git remote rm paul</div><div class="line">$ git remote</div><div class="line">origin</div></pre></td></tr></table></figure>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。</p>
<h3 id="列显已有的标签"><a href="#列显已有的标签" class="headerlink" title="列显已有的标签"></a>列显已有的标签</h3><p>列出现有标签的命令非常简单，直接运行<code>git tag</code>即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git tag</div><div class="line">v0.<span class="number">1</span></div><div class="line">v1.<span class="number">3</span></div></pre></td></tr></table></figure>
<p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p>
<p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git tag -l <span class="string">'v1.4.2.*'</span></div><div class="line">v1.<span class="number">4.2</span>.<span class="number">1</span></div><div class="line">v1.<span class="number">4.2</span>.<span class="number">2</span></div><div class="line">v1.<span class="number">4.2</span>.<span class="number">3</span></div><div class="line">v1.<span class="number">4.2</span>.<span class="number">4</span></div></pre></td></tr></table></figure>
<h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特 定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标 签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<h4 id="含附注的标签"><a href="#含附注的标签" class="headerlink" title="含附注的标签"></a>含附注的标签</h4><p>创建一个含附注类型的标签非常简单，用<code>-a</code>（译注：取 annotated 的首字母）指定标签名字即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.<span class="number">4</span> -m <span class="string">'my version 1.4'</span></div><div class="line">$ git tag</div><div class="line">v0.<span class="number">1</span></div><div class="line">v1.<span class="number">3</span></div><div class="line">v1.<span class="number">4</span></div></pre></td></tr></table></figure>
<h4 id="轻量级标签"><a href="#轻量级标签" class="headerlink" title="轻量级标签"></a>轻量级标签</h4><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个<code>-a</code>，<code>-s</code> 或 <code>-m</code> 选项都不用，直接给出标签名字即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git tag v1.<span class="number">4</span>-lw</div><div class="line">$ git tag</div><div class="line">v0.<span class="number">1</span></div><div class="line">v1.<span class="number">3</span></div><div class="line">v1.<span class="number">4</span></div><div class="line">v1.<span class="number">4</span>-lw</div><div class="line">v1.<span class="number">5</span></div></pre></td></tr></table></figure>
<h3 id="显示标签内容"><a href="#显示标签内容" class="headerlink" title="显示标签内容"></a>显示标签内容</h3><p>可以使用<code>git show</code>命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ git show v1.<span class="number">4</span></div><div class="line">tag v1.<span class="number">4</span></div><div class="line">Tagger: Scott Chacon </div><div class="line">Date:   Mon Feb <span class="number">9</span> <span class="number">14</span>:<span class="number">45</span>:<span class="number">11</span> <span class="number">2009</span> -<span class="number">0800</span></div><div class="line"></div><div class="line">my version <span class="number">1.4</span></div><div class="line">commit <span class="number">15027957951</span>b64cf874c3557a0f3547bd83b3ff6</div><div class="line">Merge: <span class="number">4</span>a447f7... a6b4c97...</div><div class="line">Author: Scott Chacon </div><div class="line"></div><div class="line">Date:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -<span class="number">0800</span></div><div class="line"></div><div class="line">    Merge branch <span class="string">'experiment'</span></div></pre></td></tr></table></figure>
<h3 id="签署标签"><a href="#签署标签" class="headerlink" title="签署标签"></a>签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的<code>-a</code>改为<code>-s</code>（译注： 取 signed 的首字母）即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git tag -s v1.<span class="number">5</span> -m <span class="string">'my signed 1.5 tag'</span></div><div class="line">You need a passphrase to unlock the secret key <span class="keyword">for</span></div><div class="line">user: <span class="string">"Scott Chacon "</span></div><div class="line"></div><div class="line"><span class="number">1024</span>-bit DSA key, ID F721C45A, created <span class="number">2009</span>-<span class="number">02</span>-<span class="number">09</span></div></pre></td></tr></table></figure>
<h3 id="验证标签"><a href="#验证标签" class="headerlink" title="验证标签"></a>验证标签</h3><p>可以使用 <code>git tag -v [tag-name]</code> （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证.</p>
<h3 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h3><p>有时候我们可能需要在以往的提交记录上打标签，这时候只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git tag -a v1.<span class="number">2</span> <span class="number">9</span>fceb02</div></pre></td></tr></table></figure>
<h3 id="分享标签"><a href="#分享标签" class="headerlink" title="分享标签"></a>分享标签</h3><p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行<code>git push origin [tagname]</code> 即可：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git push origin v1.<span class="number">5</span></div><div class="line">Counting objects: <span class="number">50</span>, done.</div><div class="line">Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.</div><div class="line">Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.</div><div class="line">Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line">* [new tag]         v1.<span class="number">5</span> -&gt; v1.<span class="number">5</span></div></pre></td></tr></table></figure>
<p>如果要一次推送所有本地新增的标签上去，可以使用<code>--tags</code>选项：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ git push origin --tags</div><div class="line">Counting objects: <span class="number">50</span>, done.</div><div class="line">Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.</div><div class="line">Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.</div><div class="line">Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line"> * [new tag]         v0.<span class="number">1</span> -&gt; v0.<span class="number">1</span></div><div class="line"> * [new tag]         v1.<span class="number">2</span> -&gt; v1.<span class="number">2</span></div><div class="line"> * [new tag]         v1.<span class="number">4</span> -&gt; v1.<span class="number">4</span></div><div class="line"> * [new tag]         v1.<span class="number">4</span>-lw -&gt; v1.<span class="number">4</span>-lw</div><div class="line"> * [new tag]         v1.<span class="number">5</span> -&gt; v1.<span class="number">5</span></div></pre></td></tr></table></figure>
<p>现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。</p>
<h2 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h2><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。</p>
<p>有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。和许多其他版本控制系统不同，Git 鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么 Git 是一个如此强大而独特的工具，并从此真正改变你的开发方式。</p>
<h3 id="何谓分支"><a href="#何谓分支" class="headerlink" title="何谓分支"></a>何谓分支</h3><p>为了理解 Git 分支的实现方式，我们需要回顾一下 Git 是如何储存数据的。或许你还记得第一章的内容，Git 保存的不是文件差异或者变化量，而只是一系列文件快照。</p>
<p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对 象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p>
<p>为直观起见，我们假设在工作目录中有三个文件，准备将它们暂存后提交。暂存操作会对每一个文件计算校验和（即第一章中提到的 SHA-1 哈希字串），然后把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 类型的对象存储这些快照），并将校验和加入暂存区域：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git add README test.rb LICENSE</div><div class="line">$ git commit -m <span class="string">'initial commit of my project'</span></div></pre></td></tr></table></figure>
<p>当使用<code>git commit</code>新建一个提交对象前，Git 会先计算每一个子目录（本例中就是项目根目录）的校验和，然后在 Git 仓库中将这些目录保存为树（tree）对象。之后 Git 创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象（项目根目录）的指针，如此它就可以在将来需要的时候，重现此次快照的内容了。</p>
<p>现在，Git 仓库中有五个对象：三个表示文件快照内容的 blob 对象；一个记录着目录树内容及其中各个文件对应 blob 对象索引的 tree 对象；以及一个包含指向 tree 对象（根目录）的索引和其他提交信息元数据的 commit 对象。概念上来说，仓库中的各个对象保存的数据和相互关系看起来如图所示：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121719_123.png" alt=""></p>
<p>作些修改后再次提交，那么这次的提交对象会包含一个指向上次提交对象的指针（译注：即下图中的 parent 对象）。两次提交后，仓库历史会变成下图的样子：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121721_705.png" alt=""></p>
<p>现在来谈分支。Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121722_450.png" alt=""></p>
<p>那么，Git 又是如何创建一个新的分支的呢？答案很简单，创建一个新的分支指针。比如新建一个 testing 分支，可以使用 <code>git branch</code>命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch testing</div></pre></td></tr></table></figure>
<p>这会在当前 commit 对象上新建一个分支指针</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121722_624.png" alt=""></p>
<p>那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。请注意它和你熟知的许多其他版本控制系统（比如 Subversion 或 CVS）里的 HEAD 概念大不相同。在 Git 中，它是一个指向你正在工作中的本地分支的指针（译注：将 HEAD 想象为当前分支的别名。）。运行<code>git branch</code> 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121723_520.png" alt=""></p>
<p>要切换到其他分支，可以执行<code>git checkout</code>命令。我们现在转换到新建的 testing 分支：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout testing</div></pre></td></tr></table></figure>
<p>这样 HEAD 就指向了 testing 分支</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121724_229.png" alt=""></p>
<p>这样的实现方式会给我们带来什么好处呢？好吧，现在不妨再提交一次：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vim test.rb</div><div class="line">$ git commit -a -m <span class="string">'made a change'</span></div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121724_283.png" alt=""></p>
<p>非常有趣，现在 testing 分支向前移动了一格，而 master 分支仍然指向原先 <code>git checkout</code> 时所在的 commit 对象。现在我们回到 master 分支看看：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121725_226.png" alt=""></p>
<p>这条命令做了两件事。它把 HEAD 指针移回到 master 分支，并把工作目录中的文件换成了 master 分支所指向的快照内容。也就是说，现在开始所做的改动，将始于本项目中一个较老的版本。它的主要作用是将 testing 分支里作出的修改暂时取消，这样你就可以向另一个方向进行开发。</p>
<p>我们作些修改后再次提交：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ vim test.rb</div><div class="line">$ git commit -a -m <span class="string">'made other changes'</span></div></pre></td></tr></table></figure>
<p>现在我们的项目提交历史产生了分叉（如图 3-9 所示），因为刚才我们创建了一个分支，转换到其中进行了一些工作，然后又回到原来的主分支进行了另外一些工作。这些改变分别孤立在不同的分支里：我们可以 在不同分支里反复切换，并在时机成熟时把它们合并到一起。而所有这些工作，仅仅需要branch 和 checkout 这两条命令就可以完成。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121725_89.png" alt=""></p>
<p>由于 Git 中的分支实际上仅是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件，所以创建和销毁一个分支就变得非常廉价。说白了，新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）那么简单，当然也就很快了。</p>
<p>这和大多数版本控制系统形成了鲜明对比，它们管理分支大多采取备份所有项目文件到特定目录的方式，所以根据项目文件数量和大小不同，可能花费的时间 也会有相当大的差别，快则几秒，慢则数分钟。而 Git 的实现与项目复杂度无关，它永远可以在几毫秒的时间内完成分支的创建和切换。同时，因为每次提交时都记录了祖先信息（译注：即parent 对象），将来要合并分支时，寻找恰当的合并基础（译注：即共同祖先）的工作其实已经自然而然地摆在那里了，所以实现起来非常容易。Git 鼓励开发者频繁使用分支，正是因为有着这些特性作保障。</p>
<h3 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h3><p>现在让我们来看一个简单的分支与合并的例子，实际工作中大体也会用到这样的工作流程：</p>
<ol>
<li>开发某个网站。 </li>
<li>为实现某个新的需求，创建一个分支。 </li>
<li>在这个分支上开展工作。</li>
</ol>
<p>假设此时，你突然接到一个电话说有个很严重的问题需要紧急修补，那么可以按照下面的方式处理：</p>
<ol>
<li>返回到原先已经发布到生产服务器上的分支。 </li>
<li>为这次紧急修补建立一个新分支，并在其中修复问题。 </li>
<li>通过测试后，回到生产服务器所在的分支，将修补分支合并进来，然后再推送到生产服务器上。 </li>
<li>切换到之前实现新需求的分支，继续工作。</li>
</ol>
<h3 id="分支的新建与切换"><a href="#分支的新建与切换" class="headerlink" title="分支的新建与切换"></a>分支的新建与切换</h3><p>首先，我们假设你正在项目中愉快地工作，并且已经提交了几次更新</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121726_3.png" alt=""></p>
<p>现在，你决定要修补问题追踪系统上的 #53 问题。顺带说明下，Git 并不同任何特定的问题追踪系统打交道。这里为了说明要解决的问题，才把新建的分支取名为 iss53。要新建并切换到该分支，运行<code>git checkout</code> 并加上 <code>-b</code> 参数：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b iss53</div><div class="line">Switched to a new branch <span class="string">"iss53"</span></div></pre></td></tr></table></figure>
<p>这相当于执行下面这两条命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch iss53</div><div class="line">$ git checkout iss53</div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121726_846.png" alt=""></p>
<p>接着你开始尝试修复问题，在提交了若干次更新后，iss53 分支的指针也会随着向前推进，因为它就是当前分支（换句话说，当前的 HEAD 指针正指向 iss53</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121727_65.png" alt=""></p>
<p>现在你就接到了那个网站问题的紧急电话，需要马上修补。有了 Git ，我们就不需要同时发布这个补丁和 iss53 里作出的修改，也不需要在创建和发布该补丁到服务器之前花费大力气来复原这些修改。唯一需要的仅仅是切换回master 分支。</p>
<p>不过在此之前，留心你的暂存区或者工作目录里，那些还没有提交的修改，它会和你即将检出的分支产生冲突从而阻止 Git 为你切换分支。切换分支的时候最好保持一个清洁的工作区域。稍后会介绍几个绕过这种问题的办法（分别叫做 stashing 和 commit amending）。目前已经提交了所有的修改，所以接下来可以正常转换到master 分支：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">"master"</span></div></pre></td></tr></table></figure>
<p>此时工作目录中的内容和你在解决问题 #53 之前一模一样，你可以集中精力进行紧急修补。这一点值得牢记：Git 会把工作目录的内容恢复为检出某分支时它所指向的那个提交对象的快照。它会自动添加、删除和修改文件以确保目录的内容和你当时提交时完全一样。</p>
<p>接下来，你得进行紧急修补。我们创建一个紧急修补分支 hotfix 来开展工作，直到搞定</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b <span class="string">'hotfix'</span></div><div class="line">Switched to a new branch <span class="string">"hotfix"</span></div><div class="line">$ vim index.html</div><div class="line">$ git commit -a -m <span class="string">'fixed the broken email address'</span></div><div class="line">[hotfix]: created <span class="number">3</span>a0874c: <span class="string">"fixed the broken email address"</span></div><div class="line"> <span class="number">1</span> files changed, <span class="number">0</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121727_499.png" alt=""></p>
<p>有必要作些测试，确保修补是成功的，然后回到 master 分支并把它合并进来，然后发布到生产服务器。用 <code>git merge</code> 命令来进行合并：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge hotfix</div><div class="line">Updating f42c576..<span class="number">3</span>a0874c</div><div class="line">Fast forward</div><div class="line"> README |    <span class="number">1</span> -</div><div class="line"> <span class="number">1</span> files changed, <span class="number">0</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>请注意，合并时出现了“Fast forward”的提示。由于当前 master 分支所在的提交对象是要并入的 hotfix 分支的直接上游，Git 只需把master 分支指针直接右移。换句话说，如果顺着一个分支走下去可以到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为<strong>快进（Fast forward）</strong>。</p>
<p>现在最新的修改已经在当前 master 分支所指向的提交对象中了，可以部署到生产服务器上去了</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121728_242.png" alt=""></p>
<p>合并之后，master 分支和 hotfix 分支指向同一位置。</p>
<p>在那个超级重要的修补发布以后，你想要回到被打扰之前的工作。由于当前 hotfix 分支和 master 都指向相同的提交对象，所以hotfix 已经完成了历史使命，可以删掉了。使用<code>git branch</code>的<code>-d</code>选项执行删除操作：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d hotfix</div><div class="line">Deleted branch hotfix (<span class="number">3</span>a0874c).</div></pre></td></tr></table></figure>
<p>现在回到之前未完成的 #53 问题修复分支上继续工作</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git checkout iss53</div><div class="line">Switched to branch <span class="string">"iss53"</span></div><div class="line">$ vim index.html</div><div class="line">$ git commit -a -m <span class="string">'finished the new footer [issue 53]'</span></div><div class="line">[iss53]: created ad82d7a: <span class="string">"finished the new footer [issue 53]"</span></div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">0</span> deletions(-)</div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121729_2.png" alt=""></p>
<p>不用担心之前 hotfix 分支的修改内容尚未包含到 iss53 中来。如果确实需要纳入此次修补，可以用<code>git merge master</code> 把 master 分支合并到 iss53；或者等 iss53 完成之后，再将iss53 分支中的更新并入 master。</p>
<h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>在问题 #53 相关的工作完成之后，可以合并回 master 分支。实际操作同前面合并 hotfix 分支差不多，只需回到master 分支，运行 <code>git merge</code> 命令指定要合并进来的分支：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge iss53</div><div class="line">Merge made by recursive.</div><div class="line"> README |    <span class="number">1</span> +</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">0</span> deletions(-)</div></pre></td></tr></table></figure>
<p>请注意，这次合并操作的底层实现，并不同于之前 hotfix 的并入方式。因为这次你的开发历史是从更早的地方开始分叉的。由于当前 master 分支所指向的提交对象（C4）并不是 iss53 分支的直接祖先，Git 不得不进行一些额外处理。就此例而言，Git 会用两个分支的末端（C4 和 C5）以及它们的共同祖先（C2）进行一次简单的三方合并计算。图 3-16 用红框标出了 Git 用于合并的三个提交对象：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121729_46.png" alt=""></p>
<p>这次，Git 没有简单地把分支指针右移，而是对三方合并后的结果重新做一个新的快照，并自动创建一个指向它的提交对象（C6）。这个提交对象比较特殊，它有两个祖先（C4 和 C5）。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121730_974.png" alt=""></p>
<p>既然之前的工作成果已经合并到 master 了，那么 iss53 也就没用了。你可以就此删除它，并在问题追踪系统里关闭该问题。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch -d iss53</div></pre></td></tr></table></figure>
<h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起（译注：逻辑上说，这种问题只能由人来裁决。）。如果你在解决问题 #53 的过程中修改了hotfix 中修改的部分，将得到类似下面的结果：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge iss53</div><div class="line">Auto-merging index.html</div><div class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html</div><div class="line">Automatic merge failed; fix conflicts and then commit the result.</div></pre></td></tr></table></figure>
<p>Git 作了合并，但<strong>没有提交</strong>，它会停下来等你解决冲突。要看看哪些文件在合并时发生冲突，可以用 <code>git status</code> 查阅：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[master*]$ git status</div><div class="line">index.html: needs merge</div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changed but not updated:</span></div><div class="line"><span class="comment">#   (use "git add  ..." to update what will be committed)</span></div><div class="line"><span class="comment">#   (use "git checkout -- ..." to discard changes in working directory)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#	unmerged:   index.html</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<p>确认所有冲突都已解决，也就是进入了暂存区，就可以用 git commit 来完成这次合并提交。</p>
<p>现在我们来看一个实际的例子。请看图 3-20，由下往上，起先我们在 master 工作到 C1，然后开始一个新分支 iss91 尝试修复 91 号缺陷，提交到 C6 的时候，又冒出一个解决该问题的新办法，于是从之前 C4 的地方又分出一个分支iss91v2，干到 C8 的时候，又回到主干 master 中提交了 C9 和 C10，再回到 iss91v2 继续工作，提交 C11，接着，又冒出个不太确定的想法，从 master 的最新提交 C10 处开了个新的分支dumbidea 做些试验。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121731_919.png" alt=""></p>
<p>现在，假定两件事情：我们最终决定使用第二个解决方案，即 iss91v2 中的办法；另外，我们把 dumbidea 分支拿给同事们看了以后，发现它竟然是个天才之作。所以接下来，我们准备抛弃原来的iss91 分支（实际上会丢弃 C5 和 C6），直接在主干中并入另外两个分支。最终的提交历史将变成图 3-21 这样：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121732_963.png" alt=""></p>
<p><strong>请务必牢记这些分支全部都是本地分支，这一点很重要。当你在使用分支及合并的时候，一切都是在你自己的 Git 仓库中进行的 — 完全不涉及与服务器的交互。</strong></p>
<h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><p>远程分支（remote branch）是对远程仓库中的分支的索引。它们是一些无法移动的本地分支；只有在 Git 进行网络交互时才会更新。远程分支就像是书签，提醒着你上次连接远程仓库时上面各分支的位置。</p>
<p>我们用 (远程仓库名)/(分支名) 这样的形式表示远程分支。比如我们想看看上次同 origin 仓库通讯时master 的样子，就应该查看 origin/master 分支。如果你和同伴一起修复某个问题，但他们先推送了一个iss53 分支到远程仓库，虽然你可能也有一个本地的 iss53 分支，但指向服务器上最新更新的却应该是 origin/iss53 分支。</p>
<p>可能有点乱，我们不妨举例说明。假设你们团队有个地址为 git.ourcompany.com 的 Git 服务器。如果你从这里克隆，Git 会自动为你将此远程仓库命名为origin，并下载其中所有的数据，建立一个指向它的 master 分支的指针，在本地命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121733_745.png" alt=""></p>
<p>如果你在本地 master 分支做了些改动，与此同时，其他人向 git.ourcompany.com 推送了他们的更新，那么服务器上的master 分支就会向前推进，而于此同时，你在本地的提交历史正朝向不同方向发展。不过只要你不和服务器通讯，你的 origin/master 指针仍然保持原位不会移动</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121734_669.png" alt=""></p>
<p>可以运行 <code>git fetch origin</code> 来同步远程服务器上的数据到本地。该命令首先找到 origin 是哪个服务器（本例为git.ourcompany.com），从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置上</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121735_607.png" alt=""></p>
<p>为了演示拥有多个远程分支（在不同的远程服务器上）的项目是如何工作的，我们假设你还有另一个仅供你的敏捷开发小组使用的内部服务器 git.team1.ourcompany.com。可以用第二章中提到的git remote add 命令把它加为当前项目的远程分支之一。我们把它命名为 teamone，以便代替原始的 Git 地址</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121736_936.png" alt=""></p>
<p>现在你可以用 git fetch teamone 来获取小组服务器上你还没有的数据了。由于当前该服务器上的内容是你 origin 服务器上的子集，Git 不会下载任何数据，而只是简单地创建一个名为teamone/master 的分支，指向 teamone 服务器上 master 分支所在的提交对象31b8e</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121737_674.png" alt=""></p>
<h3 id="推送本地分支"><a href="#推送本地分支" class="headerlink" title="推送本地分支"></a>推送本地分支</h3><p>要想和其他人分享某个本地分支，你需要把它推送到一个你拥有写权限的远程仓库。你的本地分支不会被自动同步到你引入的远程服务器上，除非你明确执行推送操作。换句话说，对于无意分享的分支，你尽管保留为私人分支好了，而只推送那些协同工作要用到的特性分支。</p>
<p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行 <code>git push (远程仓库名) (分支名)</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git push origin serverfix</div><div class="line">Counting objects: <span class="number">20</span>, done.</div><div class="line">Compressing objects: <span class="number">100</span>% (<span class="number">14</span>/<span class="number">14</span>), done.</div><div class="line">Writing objects: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), <span class="number">1.74</span> KiB, done.</div><div class="line">Total <span class="number">15</span> (delta <span class="number">5</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line"> * [new branch]      serverfix -&gt; serverfix</div></pre></td></tr></table></figure>
<p>这其实有点像条捷径。Git 自动把 serverfix 分支名扩展为 refs/heads/serverfix:refs/heads/serverfix，意为“取出我在本地的 serverfix 分支，推送到远程仓库的 serverfix 分支中去”</p>
<p>也可以运行 <code>git push origin serverfix:serferfix</code> 来实现相同的效果，它的意思是“上传我本地的 serverfix 分支到远程仓库中去，仍旧称它为 serverfix 分支”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作awesomebranch，可以用 <code>git push origin serverfix:awesomebranch</code> 来推送数据。</p>
<p>接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/serverfix：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin</div><div class="line">remote: Counting objects: <span class="number">20</span>, done.</div><div class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">14</span>/<span class="number">14</span>), done.</div><div class="line">remote: Total <span class="number">15</span> (delta <span class="number">5</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</div><div class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), done.</div><div class="line">From git@github.com:schacon/simplegit</div><div class="line"> * [new branch]      serverfix    -&gt; origin/serverfix</div></pre></td></tr></table></figure>
<p>值得注意的是，在 fetch 操作下载好新的远程分支之后，你仍然无法在本地编辑该远程仓库中的分支。换句话说，在本例中，你不会有一个新的serverfix 分支，有的只是一个你无法移动的 origin/serverfix 指针。</p>
<h3 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h3><p>从远程分支 checkout 出来的本地分支，称为<em>跟踪分支(tracking branch)</em>。跟踪分支是一种和远程分支有直接联系的本地分支。在跟踪分支里输入git push，Git 会自行推断应该向哪个服务器的哪个分支推送数据。反过来，在这些分支里运行 git pull 会获取所有远程索引，并把它们的数据都合并到本地分支中来。</p>
<p>在克隆仓库时，Git 通常会自动创建一个名为 master 的分支来跟踪 origin/master。这正是<code>git push</code> 和 <code>git pull</code> 一开始就能正常工作的原因。当然，你可以随心所欲地设定为其它跟踪分支，比如origin 上除了 master 之外的其它分支。刚才我们已经看到了这样的一个例子：<code>git checkout -b [分支名] [远程名]/[分支名]</code>。如果你有 1.6.2 以上版本的 Git，还可以用<code>--track</code> 选项简化：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout --track origin/serverfix</div><div class="line">Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</div><div class="line">Switched to a new branch <span class="string">"serverfix"</span></div></pre></td></tr></table></figure>
<p>要为本地分支设定不同于远程分支的名字，只需在前个版本的命令里换个名字：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b sf origin/serverfix</div><div class="line">Branch sf set up to track remote branch refs/remotes/origin/serverfix.</div><div class="line">Switched to a new branch <span class="string">"sf"</span></div></pre></td></tr></table></figure>
<p>现在你的本地分支 sf 会自动向 origin/serverfix 推送和抓取数据了。</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p>如果不再需要某个远程分支了，比如搞定了某个特性并把它合并进了远程的 master 分支（或任何其他存放稳定代码的地方），可以用这个非常<strong>无厘头</strong>的语法来删除它：<code>git push [远程名] :[分支名]</code>。如果想在服务器上删除serverfix 分支，运行下面的命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git push origin :serverfix</div><div class="line">To git@github.com:schacon/simplegit.git</div><div class="line"> - [deleted]         serverfix</div></pre></td></tr></table></figure>
<p>咚！服务器上的分支没了。你最好特别留心这一页，因为你一定会用到那个命令，而且你很可能会忘掉它的语法。有种方便记忆这条命令的方法：记住我们不久前见过的 <code>git push [远程名] [本地分支]:[远程分支]</code> 语法，如果省略 [本地分支]，那就等于是在说“在这里提取空白然后把它变成[远程分支]”。</p>
<h3 id="分支的衍合"><a href="#分支的衍合" class="headerlink" title="分支的衍合"></a>分支的衍合</h3><p>把一个分支整合到另一个分支的办法有两种：merge 和 rebase（译注：rebase 的翻译暂定为“衍合”，大家知道就可以了。）。在本章我们会学习什么是衍合，如何使用衍合，为什么衍合操作如此富有魅力，以及我们应该在什么情况下使用衍合。</p>
<h4 id="基本的衍合操作"><a href="#基本的衍合操作" class="headerlink" title="基本的衍合操作"></a>基本的衍合操作</h4><p>请回顾之前有关合并的一节，你会看到开发进程分叉到两个不同分支，又各自提交了更新。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121738_258.png" alt=""></p>
<p>之前介绍过，最容易的整合分支的方法是 merge 命令，它会把两个分支最新的快照（C3 和 C4）以及二者最新的共同祖先（C2）进行三方合并，合并的结果是产生一个新的提交对象（C5）。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121738_893.png" alt=""></p>
<p>其实，还有另外一个选择：你可以把在 C3 里产生的变化补丁在 C4 的基础上重新打一遍。在 Git 里，这种操作叫做<em>衍合（rebase）</em>。有了 rebase 命令，就可以把在一个分支里提交的改变移到另一个分支里重放一遍。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line">First, rewinding head to replay your work on top of it...</div><div class="line">Applying: added staged command</div></pre></td></tr></table></figure>
<p>它的原理是回到两个分支最近的共同祖先，根据当前分支（也就是要进行衍合的分支 experiment）后续的历次提交对象（这里只有一个 C3），生成一系列文件补丁，然后以基底分支（也就是主干分支master）最后一个提交对象（C4）为新的出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象（C3’），从而改写 experiment 的提交历史，使它成为 master 分支的<strong>直接下游</strong></p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121739_386.png" alt=""></p>
<p>把 C3 里产生的改变到 C4 上重演一遍。</p>
<p>现在回到 master 分支，进行一次快进合并</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121739_29.png" alt=""></p>
<p>现在的 C3’ 对应的快照，其实和普通的三方合并，即上个例子中的 C5 对应的快照内容一模一样了。虽然最后整合得到的结果没有任何区别，但衍合能产生一个更为整洁的提交历史。如果视察一个衍合过的分支的历史记录，看起来会更 清楚：仿佛所有修改都是在一根线上先后进行的，尽管实际上它们原本是同时并行发生的。</p>
<p>一般我们使用衍合的目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个分支里进行开发，当准备向主项目提交补丁的时候，根据最新的origin/master 进行一次衍合操作然后再提交，这样维护者就不需要做任何整合工作（译注：实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次快进合并，或者直接采纳你提交的补丁。</p>
<p>请注意，合并结果中最后一次提交所指向的快照，无论是通过衍合，还是三方合并，都会得到相同的快照内容，只不过提交历史不同罢了。衍合是按照每行的修改次序重演一遍修改，而合并是把最终结果合在一起。</p>
<h4 id="有趣的衍合"><a href="#有趣的衍合" class="headerlink" title="有趣的衍合"></a>有趣的衍合</h4><p>衍合也可以放到其他分支进行，并不一定非得根据分化之前的分支。以图的历史为例，我们为了给服务器端代码添加一些功能而创建了特性分支 server，然后提交 C3 和 C4。然后又从 C3 的地方再增加一个client 分支来对客户端代码进行一些相应修改，所以提交了 C8 和 C9。最后，又回到 server 分支提交了 C10。</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121740_319.png" alt=""></p>
<p>假设在接下来的一次软件发布中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）。这个时候，我们就可以把基于 server 分支而非 master 分支的改变（即 C8 和 C9），跳过 server 直接放到master 分支中重演一遍，但这需要用 git rebase 的 –onto 选项指定新的基底分支master：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase --onto master server client</div></pre></td></tr></table></figure>
<p>这好比在说：“取出 client 分支，找出 client 分支和 server 分支的共同祖先之后的变化，然后把它们在master 上重演一遍”。是不是有点复杂？不过它的结果如图 3-32 所示，非常酷（译注：虽然 client 里的 C8, C9 在 C3 之后，但这仅表明时间上的先后，而非在 C3 修改的基础上进一步改动，因为server 和 client 这两个分支对应的代码应该是两套文件，虽然这么说不是很严格，但应理解为在 C3 时间点之后，对另外的文件所做的 C8，C9 修改，放到主干重演。）：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121740_891.png" alt=""></p>
<p>现在可以快进 master 分支了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge client</div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121741_142.png" alt=""></p>
<p>现在我们决定把 server 分支的变化也包含进来。我们可以直接把 server 分支衍合到 master，而不用手工切换到 server 分支后再执行衍合操作 — git rebase [主分支] [特性分支] 命令会先取出特性分支server，然后在主分支 master 上重演：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rebase master server</div></pre></td></tr></table></figure>
<p>于是，server 的进度应用到 master 的基础上，如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121742_594.png" alt=""></p>
<p>然后就可以快进主干分支 master 了：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge server</div></pre></td></tr></table></figure>
<p>现在 client 和 server 分支的变化都已经集成到主干分支来了，可以删掉它们了。最终我们的提交历史会变成图</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git branch -d client</div><div class="line">$ git branch -d server</div></pre></td></tr></table></figure>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121743_361.png" alt=""></p>
<h4 id="衍合的风险"><a href="#衍合的风险" class="headerlink" title="衍合的风险"></a>衍合的风险</h4><p>呃，奇妙的衍合也并非完美无缺，要用它得遵守一条准则：</p>
<p><strong>一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作</strong>。</p>
<p>如果你遵循这条金科玉律，就不会出差错。否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</p>
<p>在进行衍合的时候，实际上抛弃了一些现存的提交对象而创造了一些类似但不同的新的提交对象。如果你把原来分支中的提交对象发布出去，并且其他人更新下载后在其基础上开展工作，而稍后你又用<code>git rebase</code> 抛弃这些提交对象，把新的重演后的提交对象发布出去的话，你的合作者就不得不重新合并他们的工作，这样当你再次从他们那里获取内容时，提交历史就会变得一团糟。</p>
<p>下面我们用一个实际例子来说明为什么公开的衍合会带来问题。假设你从一个中央服务器克隆然后在它的基础上搞了一些开发，提交历史类似图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121743_370.png" alt=""></p>
<p>现在，某人在 C1 的基础上做了些改变，并合并他自己的分支得到结果 C6，推送到中央服务器。当你抓取并合并这些数据到你本地的开发分支中后，会得到合并结果 C7，历史提交会变成图 </p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121744_939.png" alt=""></p>
<p>接下来，那个推送 C6 上来的人决定用衍合取代之前的合并操作；继而又用 git push –force 覆盖了服务器上的历史，得到 C4’。而之后当你再从服务器上下载最新提交后，会得到：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121745_75.png" alt=""></p>
<p>下载更新后需要合并，但此时衍合产生的提交对象 C4’ 的 SHA-1 校验值和之前 C4 完全不同，所以 Git 会把它们当作新的提交对象处理，而实际上此刻你的提交历史 C7 中早已经包含了 C4 的修改内容，于是合并操作会把 C7 和 C4’ 合并为 C8</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201121746_276.png" alt=""></p>
<p>C8 这一步的合并是迟早会发生的，因为只有这样你才能和其他协作者提交的内容保持同步。而在 C8 之后，你的提交历史里就会同时包含 C4 和 C4’，两者有着不同的 SHA-1 校验值，如果用git log 查看历史，会看到两个提交拥有相同的作者日期与说明，令人费解。而更糟的是，当你把这样的历史推送到服务器后，会再次把这些衍合后的提交引入到中央服务 器，进一步困扰其他人（译注：这个例子中，出问题的责任方是那个发布了 C6 后又用衍合发布 C4’ 的人，其他人会因此反馈双重历史到共享主干，从而混淆大家的视听。）。</p>
<p>如果把衍合当成一种在推送之前清理提交历史的手段，而且仅仅衍合那些尚未公开的提交对象，就没问题。如果衍合那些已经公开的提交对象，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>
<h2 id="服务器上的git"><a href="#服务器上的git" class="headerlink" title="服务器上的git"></a>服务器上的git</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTP 协议。下面分别介绍一下哪些情形应该使用（或避免使用）这些协议。</p>
<p>值得注意的是，除了 HTTP 协议外，其他所有协议都要求在服务器端安装并运行 Git。</p>
<h4 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h4><p>Git 使用的传输协议中最常见的可能就是 SSH 了。这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。SSH 也是唯一一个同时支持读写操作的网络协议。另外两个网络协议（HTTP 和 Git）通常都是只读的，所以虽然二者对大多数人都可用，但执行写操作时还是需要 SSH。SSH 同时也是一个验证授权的网络协议；而因为其普遍性，一般架设和使用都很容易。</p>
<p>通过 SSH 克隆一个 Git 仓库，你可以像下面这样给出 ssh:// 的 URL：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone ssh://user@server:project.git</div></pre></td></tr></table></figure>
<p>或者不指明某个协议 — 这时 Git 会默认使用 SSH ：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone user@server:project.git</div></pre></td></tr></table></figure>
<p>如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><p>使用 SSH 的好处有很多。首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用 SSH。其次，SSH 架设相对比较简单 — SSH 守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。再次，通过 SSH 进行访问是安全的 — 所有数据传输都是加密和授权的。最后，和 Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。如果你仅仅在公司网络里使用，SSH 可能是你唯一需要使用的协议。如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。</p>
<h4 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h4><p>接下来是 Git 协议。这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418），而无需任何授权。打算支持 Git 协议的仓库，需要先创建git-export-daemon-ok 文件 — 它是协议进程提供仓库服务的必要条件 — 但除此之外该服务没有什么安全措施。要么所有人都能克隆 Git 仓库，要么谁也不能。这也意味着该协议通常不能用来进行推送。你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。不用说，这是十分罕见的情况。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><p>Git 协议是现存最快的传输协议。如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。</p>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般的做法是，同时提供 SSH 接口，让几个开发者拥有推送（写）权限，其他人通过git:// 拥有只读权限。Git 协议可能也是最难架设的协议。它要求有单独的守护进程，需要定制 — 我们将在本章的 “Gitosis” 一节详细介绍它的架设 — 需要设定xinetd 或类似的程序，而这些工作就没那么轻松了。该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。大型企业级防火墙通常会封锁这个少见的端口。</p>
<h4 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><p>使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。花费不过几分钟。HTTP 协议不会占用过多服务器资源。因为它一般只用到静态的 HTTP 服务提供所有数据，普通的 Apache 服务器平均每秒能支撑数千个文件的并发访问 — 哪怕让一个小型服务器超载都很难。</p>
<p>你也可以通过 HTTPS 提供只读的仓库，这意味着你可以加密传输内容；你甚至可以要求客户端使用特定签名的 SSL 证书。一般情况下，如果到了这一步，使用 SSH 公共密钥可能是更简单的方案；不过也存在一些特殊情况，这时通过 HTTPS 使用带签名的 SSL 证书或者其他基于 HTTP 的只读连接授权方式是更好的解决方案。</p>
<p>HTTP 还有个额外的好处：HTTP 是一个如此常见的协议，以至于企业级防火墙通常都允许其端口的通信。</p>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><p>HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需供应的能力 — 传输过程中没有服务端的动态计算 — 因而 HTTP 协议经常会被称为<em>傻瓜（dumb）</em>协议。</p>
<h2 id="分布式git"><a href="#分布式git" class="headerlink" title="分布式git"></a>分布式git</h2><p>###集成管理员工作流<br>由于 Git 允许使用多个远程仓库，开发者便可以建立自己的公共仓库，往里面写数据并共享给他人，而同时又可以从别人的仓库中提取他们的更新过来。这种情形通常都会有 个代表着官方发布的项目仓库（blessed repository），开发者们由此仓库克隆出一个自己的公共仓库（developer public），然后将自己的提交推送上去，请求官方仓库的维护者拉取更新合并到主项目。维护者在自己的本地也有个克隆仓库（integration manager），他可以将你的公共仓库作为远程仓库添加进来，经过测试无误后合并到主干分支，然后再推送到官方仓库。工作流程看起来就像图所示：</p>
<ol>
<li>项目维护者可以推送数据到公共仓库 blessed repository。</li>
<li>贡献者克隆此仓库，修订或编写新代码。</li>
<li>贡献者推送数据到自己的公共仓库 developer public。 </li>
<li>贡献者给维护者发送邮件，请求拉取自己的最新修订。</li>
<li>维护者在自己本地的 integration manger 仓库中，将贡献者的仓库加为远程仓库，合并更新并做测试。</li>
<li>维护者将合并后的更新推送到主仓库 blessed repository。</li>
</ol>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122033_852.png" alt=""></p>
<p>在 GitHub 网站上使用得最多的就是这种工作流。人们可以复制（fork 亦即克隆）某个项目到自己的列表中，成为自己的公共仓库。随后将自己的更新提交到这个仓库，所有人都可以看到你的每次更新。这么做最主要的优点在于，你可 以按照自己的节奏继续工作，而不必等待维护者处理你提交的更新；而维护者也可以按照自己的节奏，任何时候都可以过来处理接纳你的贡献。</p>
<h3 id="提交指南"><a href="#提交指南" class="headerlink" title="提交指南"></a>提交指南</h3><p>开始分析特定用例之前，先来了解下如何撰写提交说明。一份好的提交指南可以帮助协作者更轻松更有效地配合。Git 项目本身就提供了一份文档（Git 项目源代码目录中Documentation/SubmittingPatches），列数了大量提示，从如何编撰提交说明到提交补丁，不一而足。</p>
<p>首先，请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方法，在提交之前，先运行 <code>git diff --check</code>，会把可能的多余白字符修正列出来。下面的示例，我已经把终端中显示为红色的白字符用<code>X</code> 替换掉：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git diff --check</div><div class="line">lib/simplegit.rb:<span class="number">5</span>: trailing whitespace.</div><div class="line">+    @git_dir = File.expand_path(git_dir)XX</div><div class="line">lib/simplegit.rb:<span class="number">7</span>: trailing whitespace.</div><div class="line">+ XXXXXXXXXXX</div><div class="line">lib/simplegit.rb:<span class="number">26</span>: trailing whitespace.</div><div class="line">+    def command(git_cmd)XXXX</div></pre></td></tr></table></figure>
<p>这样在提交之前你就可以看到这类问题，及时解决以免困扰其他开发者。</p>
<p>最后需要谨记的是提交说明的撰写。写得好可以让大家协作起来更轻松。一般来说，提交说明最好限制在一行以内，50 个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解。Git 项目本身需要开发者撰写详尽注解，包括本次修订的因由，以及前后不同实现之间的比较，我们也该借鉴这种做法。另外，提交说明应该用祈使现在式语态，比如， 不要说成 “I added tests for” 或 “Adding tests for” 而应该用 “Add tests for”。下面是来自 tpope.net 的 Tim Pope 原创的提交说明格式模版，供参考：</p>
<blockquote>
<p>本次更新的简要描述（50 个字符以内）</p>
<p>如果必要，此处展开详尽阐述。段落宽度限定在 72 个字符以内。<br>某些情况下，第一行的简要描述将用作邮件标题，其余部分作为邮件正文。<br>其间的空行是必要的，以区分两者（当然没有正文另当别论）。<br>如果并在一起，rebase 这样的工具就可能会迷惑。</p>
<p>另起空行后，再进一步补充其他说明。</p>
<ul>
<li><p>可以使用这样的条目列举式。</p>
</li>
<li><p>一般以单个空格紧跟短划线或者星号作为每项条目的起始符。每个条目间用一空行隔开。<br>不过这里按自己项目的约定，可以略作变化。</p>
</li>
</ul>
</blockquote>
<h3 id="私有的小型团队"><a href="#私有的小型团队" class="headerlink" title="私有的小型团队"></a>私有的小型团队</h3><p>让我们来看看，两个开发者一 起使用同一个共享仓库，会发生些什么。第一个人，John，克隆了仓库，作了些更新，在本地提交。（下面的例子中省略了常规提示，用… 代替以节约版面。）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># John's Machine</span></div><div class="line">$ git clone john@githost:simplegit.git</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /home/john/simplegit/.git/</div><div class="line">...</div><div class="line">$ cd simplegit/</div><div class="line">$ vim lib/simplegit.rb </div><div class="line">$ git commit -am <span class="string">'removed invalid default value'</span></div><div class="line">[master <span class="number">738</span>ee87] removed invalid default value</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>第二个开发者，Jessica，一样这么做：克隆仓库，提交更新：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Jessica's Machine</span></div><div class="line">$ git clone jessica@githost:simplegit.git</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /home/jessica/simplegit/.git/</div><div class="line">...</div><div class="line">$ cd simplegit/</div><div class="line">$ vim TODO </div><div class="line">$ git commit -am <span class="string">'add reset task'</span></div><div class="line">[master fbff5bc] add reset task</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">0</span> deletions(-)</div></pre></td></tr></table></figure>
<p>现在，Jessica 将她的工作推送到服务器上：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Jessica's Machine</span></div><div class="line">$ git push origin master</div><div class="line">...</div><div class="line">To jessica@githost:simplegit.git</div><div class="line">   <span class="number">1</span>edee6b..fbff5bc  master -&gt; master</div></pre></td></tr></table></figure>
<p>John 也尝试推送自己的工作上去：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># John's Machine</span></div><div class="line">$ git push origin master</div><div class="line">To john@githost:simplegit.git</div><div class="line"> ! [rejected]        master -&gt; master (non-fast forward)</div><div class="line">error: failed to push some refs to <span class="string">'john@githost:simplegit.git'</span></div></pre></td></tr></table></figure>
<p>John 的推送操作被驳回，因为 Jessica 已经推送了新的数据上去。请注意，特别是你用惯了 Subversion 的话，这里其实修改的是两个文件，而不是同一个文件的同一个地方。Subversion 会在服务器端自动合并提交上来的更新，而 Git 则必须先在本地合并后才能推送。于是，John 不得不先把 Jessica 的更新拉下来：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin</div><div class="line">...</div><div class="line">From john@githost:simplegit</div><div class="line"> + <span class="number">049</span>d078...fbff5bc master     -&gt; origin/master</div></pre></td></tr></table></figure>
<p>此刻，John 的本地仓库如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122034_158.png" alt=""></p>
<p>虽然 John 下载了 Jessica 推送到服务器的最近更新（fbff5），但目前只是 origin/master 指针指向它，而当前的本地分支master 仍然指向自己的更新（738ee），所以需要先把她的提交合并过来，才能继续推送数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git merge origin/master</div><div class="line">Merge made by recursive.</div><div class="line"> TODO |    <span class="number">1</span> +</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">0</span> deletions(-)</div></pre></td></tr></table></figure>
<p>还好，合并过程非常顺利，没有冲突，现在 John 的提交历史如图 </p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122035_917.png" alt=""></p>
<p>现在，John 应该再测试一下代码是否仍然正常工作，然后将合并结果（72bbc）推送到服务器上：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div><div class="line">...</div><div class="line">To john@githost:simplegit.git</div><div class="line">   fbff5bc..<span class="number">72</span>bbc59  master -&gt; master</div></pre></td></tr></table></figure>
<p>最终，John 的提交历史变为图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122035_292.png" alt=""></p>
<p>而在这段时间，Jessica 已经开始在另一个特性分支工作了。她创建了 issue54 并提交了三次更新。她还没有下载 John 提交的合并结果，所以提交历史如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122035_852.png" alt=""></p>
<p>Jessica 想要先和服务器上的数据同步，所以先下载数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Jessica's Machine</span></div><div class="line">$ git fetch origin</div><div class="line">...</div><div class="line">From jessica@githost:simplegit</div><div class="line">   fbff5bc..<span class="number">72</span>bbc59  master     -&gt; origin/master</div></pre></td></tr></table></figure>
<p>于是 Jessica 的本地仓库历史多出了 John 的两次提交（738ee 和 72bbc），如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122036_995.png" alt=""></p>
<p>现在，Jessica 可以将特性分支上的工作并到 master 分支，然后再并入 John 的工作（origin/master）到自己的master 分支，最后再推送回服务器。当然，得先切回主分支才能集成所有数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">Switched to branch <span class="string">"master"</span></div><div class="line">Your branch is behind <span class="string">'origin/master'</span> by <span class="number">2</span> commits, and can be fast-forwarded.</div></pre></td></tr></table></figure>
<p>要合并 origin/master 或 issue54 分支，谁先谁后都没有关系，因为它们都在上游（upstream）（<strong>译注：想像分叉的更新像是汇流成河的源头，所以上游 upstream 是指最新的提交</strong>），所以无所谓先后顺序，最终合并后的内容快照都是一样的，而仅是提交历史看起来会有些先后差别。Jessica 选择先合并issue54：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git merge issue54</div><div class="line">Updating fbff5bc..<span class="number">4</span>af4298</div><div class="line">Fast forward</div><div class="line"> README           |    <span class="number">1</span> +</div><div class="line"> lib/simplegit.rb |    <span class="number">6</span> +++++-</div><div class="line"> <span class="number">2</span> files changed, <span class="number">6</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>正如所见，没有冲突发生，仅是一次简单快进。现在 Jessica 开始合并 John 的工作（origin/master）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge origin/master</div><div class="line">Auto-merging lib/simplegit.rb</div><div class="line">Merge made by recursive.</div><div class="line"> lib/simplegit.rb |    <span class="number">2</span> +-</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>所有的合并都非常干净。现在 Jessica 的提交历史如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122037_94.png" alt=""></p>
<p>现在 Jessica 已经可以在自己的 master 分支中访问 origin/master 的最新改动了，所以她应该可以成功推送最后的合并结果到服务器上（假设 John 此时没再推送新数据上来）：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin master</div><div class="line">...</div><div class="line">To jessica@githost:simplegit.git</div><div class="line">   <span class="number">72</span>bbc59..<span class="number">8059</span>c15  master -&gt; master</div></pre></td></tr></table></figure>
<p>至此，每个开发者都提交了若干次，且成功合并了对方的工作成果，最新的提交历史如图 </p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122037_695.png" alt=""></p>
<p>以上就是最简单的协作方式之一：先在自己的特性分支中工作一段时间，完成后合并到自己的 master 分支；然后下载合并 origin/master 上的更新（如果有的话），再推回远程服务器。一般的协作流程如图所示：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122038_871.png" alt=""></p>
<h3 id="私有团队间协作"><a href="#私有团队间协作" class="headerlink" title="私有团队间协作"></a>私有团队间协作</h3><p>现在我们来看更大一点规模的私有团队协作。如果有几个小组分头负责若干特性的开发和集成，那他们之间的协作过程是怎样的。</p>
<p>假设 John 和 Jessica 一起负责开发某项特性 A，而同时 Jessica 和 Josie 一起负责开发另一项功能 B。公司使用典型的集成管理员式工作流，每个组都有一名管理员负责集成本组代码，及更新项目主仓库的master 分支。所有开发都在代表小组的分支上进行。</p>
<p>让我们跟随 Jessica 的视角看看她的工作流程。她参与开发两项特性，同时和不同小组的开发者一起协作。克隆生成本地仓库后，她打算先着手开发特性 A。于是创建了新的featureA 分支，继而编写代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Jessica's Machine</span></div><div class="line">$ git checkout -b featureA</div><div class="line">Switched to a new branch <span class="string">"featureA"</span></div><div class="line">$ vim lib/simplegit.rb</div><div class="line">$ git commit -am <span class="string">'add limit to log function'</span></div><div class="line">[featureA <span class="number">3300904</span>] add limit to log <span class="keyword">function</span></div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>此刻，她需要分享目前的进展给 John，于是她将自己的 featureA 分支提交到服务器。由于 Jessica 没有权限推送数据到主仓库的master 分支（只有集成管理员有此权限），所以只能将此分支推上去同 John 共享协作：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin featureA</div><div class="line">...</div><div class="line">To jessica@githost:simplegit.git</div><div class="line"> * [new branch]      featureA -&gt; featureA</div></pre></td></tr></table></figure>
<p>Jessica 发邮件给 John 让他上来看看 featureA 分支上的进展。在等待他的反馈之前，Jessica 决定继续工作，和 Josie 一起开发featureB 上的特性 B。当然，先创建此分支，分叉点以服务器上的 master 为起点：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Jessica's Machine</span></div><div class="line">$ git fetch origin</div><div class="line">$ git checkout -b featureB origin/master</div><div class="line">Switched to a new branch <span class="string">"featureB"</span></div></pre></td></tr></table></figure>
<p>随后，Jessica 在 featureB 上提交了若干更新：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ vim lib/simplegit.rb</div><div class="line">$ git commit -am <span class="string">'made the ls-tree function recursive'</span></div><div class="line">[featureB e5b0fdc] made the ls-tree <span class="keyword">function</span> recursive</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</div><div class="line">$ vim lib/simplegit.rb</div><div class="line">$ git commit -am <span class="string">'add ls-files'</span></div><div class="line">[featureB <span class="number">8512791</span>] add ls-files</div><div class="line"> <span class="number">1</span> files changed, <span class="number">5</span> insertions(+), <span class="number">0</span> deletions(-)</div></pre></td></tr></table></figure>
<p>现在 Jessica 的更新历史如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122038_536.png" alt=""></p>
<p>Jessica 正准备推送自己的进展上去，却收到 Josie 的来信，说是她已经将自己的工作推到服务器上的 featureBee 分支了。这样，Jessica 就必须先将 Josie 的代码合并到自己本地分支中，才能再一起推送回服务器。她用git fetch 下载 Josie 的最新代码：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin</div><div class="line">...</div><div class="line">From jessica@githost:simplegit</div><div class="line"> * [new branch]      featureBee -&gt; origin/featureBee</div></pre></td></tr></table></figure>
<p>然后 Jessica 使用 git merge 将此分支合并到自己分支中：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git merge origin/featureBee</div><div class="line">Auto-merging lib/simplegit.rb</div><div class="line">Merge made by recursive.</div><div class="line"> lib/simplegit.rb |    <span class="number">4</span> ++++</div><div class="line"> <span class="number">1</span> files changed, <span class="number">4</span> insertions(+), <span class="number">0</span> deletions(-)</div></pre></td></tr></table></figure>
<p>合并很顺利，但另外有个小问题：她要推送自己的 featureB 分支到服务器上的 featureBee 分支上去。当然，她可以使用冒号（:）格式指定目标分支：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git push origin featureB:featureBee</div><div class="line">...</div><div class="line">To jessica@githost:simplegit.git</div><div class="line">   fba9af8..cd685d1  featureB -&gt; featureBee</div></pre></td></tr></table></figure>
<p>接下来，John 发邮件给 Jessica 告诉她，他看了之后作了些修改，已经推回服务器 featureA 分支，请她过目下。于是 Jessica 运行git fetch 下载最新数据：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git fetch origin</div><div class="line">...</div><div class="line">From jessica@githost:simplegit</div><div class="line">   <span class="number">3300904</span>..aad881d  featureA   -&gt; origin/featureA</div></pre></td></tr></table></figure>
<p>最后，她将 John 的工作合并到自己的 featureA 分支中：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git checkout featureA</div><div class="line">Switched to branch <span class="string">"featureA"</span></div><div class="line">$ git merge origin/featureA</div><div class="line">Updating <span class="number">3300904</span>..aad881d</div><div class="line">Fast forward</div><div class="line"> lib/simplegit.rb |   <span class="number">10</span> +++++++++-</div><div class="line"><span class="number">1</span> files changed, <span class="number">9</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>Jessica 稍做一番修整后同步到服务器：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git commit -am <span class="string">'small tweak'</span></div><div class="line">[featureA ed774b3] small tweak</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</div><div class="line">$ git push origin featureA</div><div class="line">...</div><div class="line">To jessica@githost:simplegit.git</div><div class="line">   <span class="number">3300904</span>..ed774b3  featureA -&gt; featureA</div></pre></td></tr></table></figure>
<p>现在的 Jessica 提交历史如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122039_393.png" alt=""></p>
<p>现在，Jessica，Josie 和 John 通知集成管理员服务器上的 featureA 及 featureBee 分支已经准备好，可以并入主线了。在管理员完成集成工作后，主分支上便多出一个新的合并提交（5399e），用 fetch 命令更新到本地后，提交历史如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122039_398.png" alt=""></p>
<p>许多开发小组改用 Git 就是因为它允许多个小组间并行工作，而在稍后恰当时机再行合并。通过共享远程分支的方式，无需干扰整体项目代码便可以开展工作，因此使用 Git 的小型团队间协作可以变得非常灵活自由。以上工作流程的时序如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122040_316.png" alt=""></p>
<h3 id="公开的小型项目"><a href="#公开的小型项目" class="headerlink" title="公开的小型项目"></a>公开的小型项目</h3><p>上面说的是私有项目协作，但要给公开项目作贡献，情况就有些不同了。因为你没有直接更新主仓库分支的权限，得寻求其它方式把工作成果交给项目维护 人。下面会介绍两种方法，第一种使用 git 托管服务商提供的仓库复制功能，一般称作 fork，比如 repo.or.cz 和 GitHub 都支持这样的操作，而且许多项目管理员都希望大家使用这样的方式。另一种方法是通过电子邮件寄送文件补丁。</p>
<p>但不管哪种方式，起先我们总需要克隆原始仓库，而后创建特性分支开展工作。基本工作流程如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git clone (url)</div><div class="line">$ cd project</div><div class="line">$ git checkout -b featureA</div><div class="line">$ (work)</div><div class="line">$ git commit</div><div class="line">$ (work)</div><div class="line">$ git commit</div></pre></td></tr></table></figure>
<p>在完成了特性分支开发，提交给项目维护者之前，先到原始项目的页面上点击“Fork”按钮，创建一个自己可写的公共仓库（译注：即下面的 url 部分，参照后续的例子，应该是git://githost/simplegit.git）。然后将此仓库添加为本地的第二个远端仓库，姑且称为 myfork：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote add myfork (url)</div></pre></td></tr></table></figure>
<p>你需要将本地更新推送到这个仓库。要是将远端 master 合并到本地再推回去，还不如把整个特性分支推上去来得干脆直接。而且，假若项目维护者未采纳你的贡献的话（不管是直接合并还是 cherry pick），都不用回退（rewind）自己的 master 分支。但若维护者合并或 cherry-pick 了你的工作，最后总还可以从他们的更新中同步这些代码。好吧，现在先把 featureA 分支整个推上去：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push myfork featureA</div></pre></td></tr></table></figure>
<p>然后通知项目管理员，让他来抓取你的代码。通常我们把这件事叫做 pull request。可以直接用 GitHub 等网站提供的 “pull request” 按钮自动发送请求通知；或手工把<code>git request-pull</code> 命令输出结果电邮给项目管理员。</p>
<p><code>request-pull</code> 命令接受两个参数，第一个是本地特性分支开始前的原始分支，第二个是请求对方来抓取的 Git 仓库 URL（译注：即下面myfork 所指的，自己可写的公共仓库）。比如现在Jessica 准备要给 John 发一个 pull requst，她之前在自己的特性分支上提交了两次更新，并把分支整个推到了服务器上，所以运行该命令会看到：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ git request-pull origin/master myfork</div><div class="line">The following changes since commit <span class="number">1</span>edee6b1d61823a2de3b09c160d7080b8d1b3a40:</div><div class="line">  John Smith (<span class="number">1</span>):</div><div class="line">        added a new <span class="keyword">function</span></div><div class="line"></div><div class="line">are available <span class="keyword">in</span> the git repository at:</div><div class="line"></div><div class="line">  git://githost/simplegit.git featureA</div><div class="line"></div><div class="line">Jessica Smith (<span class="number">2</span>):</div><div class="line">      add limit to log <span class="keyword">function</span></div><div class="line">      change log output to <span class="number">30</span> from <span class="number">25</span></div><div class="line"></div><div class="line"> lib/simplegit.rb |   <span class="number">10</span> +++++++++-</div><div class="line"> <span class="number">1</span> files changed, <span class="number">9</span> insertions(+), <span class="number">1</span> deletions(-)</div></pre></td></tr></table></figure>
<p>输出的内容可以直接发邮件给管理者，他们就会明白这是从哪次提交开始旁支出去的，该到哪里去抓取新的代码，以及新的代码增加了哪些功能等等。</p>
<p><strong>像这样随时保持自己的 master 分支和官方 origin/master 同步，并将自己的工作限制在特性分支上的做法，既方便又灵活，采纳和丢弃都轻而易举。就算原始主干发生变化，我们也能重新衍合提供新的补丁</strong>。比如现在要开始第二项特性的开发，不要在原来已推送的特性分支上继续，还是按原始master 开始：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b featureB origin/master</div><div class="line">$ (work)</div><div class="line">$ git commit</div><div class="line">$ git push myfork featureB</div><div class="line">$ (email maintainer)</div><div class="line">$ git fetch origin</div></pre></td></tr></table></figure>
<p>现在，A、B 两个特性分支各不相扰，如同竹筒里的两颗豆子，队列中的两个补丁，你随时都可以分别从头写过，或者衍合，或者修改，而不用担心特性代码的交叉混杂。如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122041_488.png" alt=""></p>
<p>假设项目管理员接纳了许多别人提交的补丁后，准备要采纳你提交的第一个分支，却发现因为代码基准不一致，合并工作无法正确干净地完成。这就需要你再次衍合到最新的 origin/master，解决相关冲突，然后重新提交你的修改：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git checkout featureA</div><div class="line">$ git rebase origin/master</div><div class="line">$ git push -f myfork featureA</div></pre></td></tr></table></figure>
<p>自然，这会重写提交历史，如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122041_903.png" alt=""></p>
<p><strong>注意，此时推送分支必须使用 -f 选项（译注：表示 force，不作检查强制重写）替换远程已有的 featureA 分支，因为新的 commit 并非原来的后续更新</strong>。当然你也可以直接推送到另一个新的分支上去，比如称作featureAv2。</p>
<p>再考虑另一种情形：管理员看过第二个分支后觉得思路新颖，但想请你改下具体实现。我们只需以当前 origin/master 分支为基准，开始一个新的特性分支featureBv2，然后把原来的 featureB 的更新拿过来，解决冲突，按要求重新实现部分代码，然后将此特性分支推送上去：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b featureBv2 origin/master</div><div class="line">$ git merge --no-commit --squash featureB</div><div class="line">$ (change implementation)</div><div class="line">$ git commit</div><div class="line">$ git push myfork featureBv2</div></pre></td></tr></table></figure>
<p>这里的 <code>--squash</code> 选项将目标分支上的所有更改全拿来应用到当前分支上，而 <code>--no-commit</code> 选项告诉 Git 此时无需自动生成和记录（合并）提交。这样，你就可以在原来代码基础上，继续工作，直到最后一起提交。</p>
<p>好了，现在可以请管理员抓取 featureBv2 上的最新代码了，如图</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20120201/20120201122042_782.png" alt=""></p>
<h2 id="git工具"><a href="#git工具" class="headerlink" title="git工具"></a>git工具</h2><h3 id="祖先引用"><a href="#祖先引用" class="headerlink" title="祖先引用"></a>祖先引用</h3><p>另一种指明某次提交的常用方法是通过它的祖先。如果你在引用最后加上一个 <code>^</code>，Git 将其理解为此次提交的父提交。 假设你的工程历史是这样的：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ git log --pretty=format:<span class="string">'%h %s'</span> --graph</div><div class="line">* <span class="number">734713</span>b fixed refs handling, added gc auto, updated tests</div><div class="line">*   d921970 Merge commit <span class="string">'phedders/rdocs'</span></div><div class="line">|\  </div><div class="line">| * <span class="number">35</span>cfb2b Some rdoc changes</div><div class="line">* | <span class="number">1</span>c002dd added some blame and merge stuff</div><div class="line">|/  </div><div class="line">* <span class="number">1</span>c36188 ignore *.gem</div><div class="line">* <span class="number">9</span>b29157 add open3_detach to gemspec file list</div></pre></td></tr></table></figure>
<p>那么，想看上一次提交，你可以使用 <code>HEAD^</code>，意思是“HEAD 的父提交”：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git show HEAD^</div><div class="line">commit d921970aadf03b3cf0e71becdaab3147ba71cdef</div><div class="line">Merge: <span class="number">1</span>c002dd... <span class="number">35</span>cfb2b...</div><div class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</div><div class="line">Date:   Thu Dec <span class="number">11</span> <span class="number">15</span>:<span class="number">08</span>:<span class="number">43</span> <span class="number">2008</span> -<span class="number">0800</span></div><div class="line"></div><div class="line">    Merge commit <span class="string">'phedders/rdocs'</span></div></pre></td></tr></table></figure>
<p>你也可以在 <code>^</code> 后添加一个数字——例如，<code>d921970^2</code> 意思是“d921970 的第二父提交”。这种语法只在合并提交时有用，因为合并提交可能有多个父提交。第一父提交是你合并时所在分支，而第二父提交是你所合并的分支：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ git show d921970^</div><div class="line">commit <span class="number">1</span>c002dd4b536e7479fe34593e72e6c6c1819e53b</div><div class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</div><div class="line">Date:   Thu Dec <span class="number">11</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">32</span> <span class="number">2008</span> -<span class="number">0800</span></div><div class="line"></div><div class="line">    added some blame and merge stuff</div><div class="line"></div><div class="line">$ git show d921970^<span class="number">2</span></div><div class="line">commit <span class="number">35</span>cfb2b795a55793d7cc56a6cc2060b4bb732548</div><div class="line">Author: Paul Hedderly &lt;paul+git@mjr.org&gt;</div><div class="line">Date:   Wed Dec <span class="number">10</span> <span class="number">22</span>:<span class="number">22</span>:<span class="number">03</span> <span class="number">2008</span> +<span class="number">0000</span></div><div class="line"></div><div class="line">    Some rdoc changes</div></pre></td></tr></table></figure>
<p>另外一个指明祖先提交的方法是 <code>~</code>。这也是指向第一父提交，所以 <code>HEAD~</code> 和 <code>HEAD^</code> 是等价的。当你指定数字的时候就明显不一样了。<code>HEAD~2</code> 是指“第一父提交的第一父提交”，也就是“祖父提交”——它会根据你指定的次数检索第一父提交。例如，在上面列出的历史记录里面，<code>HEAD~3</code> 会是</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git show HEAD~<span class="number">3</span></div><div class="line">commit <span class="number">1</span>c3618887afb5fbcbea25b7c013f4e2114448b8d</div><div class="line">Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;</div><div class="line">Date:   Fri Nov <span class="number">7</span> <span class="number">13</span>:<span class="number">47</span>:<span class="number">59</span> <span class="number">2008</span> -<span class="number">0500</span></div><div class="line"></div><div class="line">    ignore *.gem</div></pre></td></tr></table></figure>
<h3 id="储藏（Stashing）"><a href="#储藏（Stashing）" class="headerlink" title="储藏（Stashing）"></a>储藏（Stashing）</h3><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。</p>
<p>“‘储藏”“可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p>
<h4 id="储藏你的工作"><a href="#储藏你的工作" class="headerlink" title="储藏你的工作"></a>储藏你的工作</h4><p>为了演示这一功能，你可以进入你的项目，在一些文件上进行工作，有可能还暂存其中一个变更。如果你运行 <code>git status</code>，你可以看到你的中间状态：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changes to be committed:</span></div><div class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      modified:   index.html</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Changed but not updated:</span></div><div class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<p>现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行 <code>git stash</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git stash</div><div class="line">Saved working directory and index state \</div><div class="line">  <span class="string">"WIP on master: 049d078 added the index file"</span></div><div class="line">HEAD is now at <span class="number">049</span>d078 added the index file</div><div class="line">(To restore them type <span class="string">"git stash apply"</span>)</div></pre></td></tr></table></figure>
<p>你的工作目录就干净了：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"><span class="comment"># On branch master</span></div><div class="line">nothing to commit (working directory clean)</div></pre></td></tr></table></figure>
<p>这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。要查看现有的储藏，你可以使用 <code>git stash list</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div><div class="line">stash@&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">049</span>d078 added the index file</div><div class="line">stash@&#123;<span class="number">1</span>&#125;: WIP on master: c264051... Revert <span class="string">"added file_size"</span></div><div class="line">stash@&#123;<span class="number">2</span>&#125;: WIP on master: <span class="number">21</span>d80a5... added number to log</div></pre></td></tr></table></figure>
<p>在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。你可以重新应用你刚刚实施的储藏，所采用的命令就是之前在原始的 stash 命令的帮助输出里提示的：<code>git stash apply</code>。如果你想应用更早的储藏，你可以通过名字指定它，像这样：git <code>stash apply stash@{2}</code>。如果你不指明，Git 默认使用最近的储藏并尝试应用它：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git stash apply</div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changed but not updated:</span></div><div class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      modified:   index.html</span></div><div class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<p>你可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。</p>
<p>对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。想那样的话，你必须在运行 git stash apply 命令时带上一个 –index 的选项来告诉命令重新应用被暂存的变更。如果你是这么做的，你应该已经回到你原来的位置：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ git stash apply --index</div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changes to be committed:</span></div><div class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      modified:   index.html</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Changed but not updated:</span></div><div class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      modified:   lib/simplegit.rb</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<p>apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行 <code>git stash drop</code>，加上你希望移除的储藏的名字：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div><div class="line">stash@&#123;<span class="number">0</span>&#125;: WIP on master: <span class="number">049</span>d078 added the index file</div><div class="line">stash@&#123;<span class="number">1</span>&#125;: WIP on master: c264051... Revert <span class="string">"added file_size"</span></div><div class="line">stash@&#123;<span class="number">2</span>&#125;: WIP on master: <span class="number">21</span>d80a5... added number to log</div><div class="line">$ git stash drop stash@&#123;<span class="number">0</span>&#125;</div><div class="line">Dropped stash@&#123;<span class="number">0</span>&#125; (<span class="number">364</span>e91f3f268f0900bc3ee613f9f733e82aaed43)</div></pre></td></tr></table></figure>
<p>你也可以运行 <code>git stash pop</code> 来重新应用储藏，同时立刻将其从堆栈中移走。</p>
<h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><p>经常有这样的事情，当你在一个项目上工作时，你需要在其中使用另外一个项目。也许它是一个第三方开发的库或者是你独立开发和并在多个父项目中使用的。这个场景下一个常见的问题产生了：你想将两个项目单独处理但是又需要在其中一个中使用另外一个。</p>
<p>这里有一个例子。假设你在开发一个网站，为之创建Atom源。你不想编写一个自己的Atom生成代码，而是决定使用一个库。你可能不得不像CPAN install或者Ruby gem一样包含来自共享库的代码，或者将代码拷贝到你的项目树中。如果采用包含库的办法，那么不管用什么办法都很难去定制这个库，部署它就更加困难了，因为你必须确保每个客户都拥有那个库。把代码包含到你自己的项目中带来的问题是，当上游被修改时，任何你进行的定制化的修改都很难归并。</p>
<p>Git 通过子模块处理这个问题。子模块允许你将一个 Git 仓库当作另外一个Git仓库的子目录。这允许你克隆另外一个仓库到你的项目中并且保持你的提交相对独立。</p>
<h4 id="子模块初步"><a href="#子模块初步" class="headerlink" title="子模块初步"></a>子模块初步</h4><p>假设你想把 Rack 库（一个 Ruby 的 web 服务器网关接口）加入到你的项目中，可能既要保持你自己的变更，又要延续上游的变更。首先你要把外部的仓库克隆到你的子目录中。你通过<code>git submodule add</code>将外部项目加为子模块：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ git submodule add git://github.com/chneukirchen/rack.git rack</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /opt/subtest/rack/.git/</div><div class="line">remote: Counting objects: <span class="number">3181</span>, done.</div><div class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">1534</span>/<span class="number">1534</span>), done.</div><div class="line">remote: Total <span class="number">3181</span> (delta <span class="number">1951</span>), reused <span class="number">2623</span> (delta <span class="number">1603</span>)</div><div class="line">Receiving objects: <span class="number">100</span>% (<span class="number">3181</span>/<span class="number">3181</span>), <span class="number">675.42</span> KiB | <span class="number">422</span> KiB/s, done.</div><div class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">1951</span>/<span class="number">1951</span>), done.</div></pre></td></tr></table></figure>
<p>现在你就在项目里的rack子目录下有了一个 Rack 项目。你可以进入那个子目录，进行变更，加入你自己的远程可写仓库来推送你的变更，从原始仓库拉取和归并等等。如果你在加入子模块后立刻运行<code>git status</code>，你会看到下面两项：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git status</div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changes to be committed:</span></div><div class="line"><span class="comment">#   (use "git reset HEAD &lt;file&gt;..." to unstage)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      new file:   .gitmodules</span></div><div class="line"><span class="comment">#      new file:   rack</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<p>首先你注意到有一个<code>.gitmodules</code>文件。这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat .gitmodules </div><div class="line">[submodule <span class="string">"rack"</span>]</div><div class="line">      path = rack</div><div class="line">      url = git://github.com/chneukirchen/rack.git</div></pre></td></tr></table></figure>
<p>如果你有多个子模块，这个文件里会有多个条目。很重要的一点是这个文件跟其他文件一样也是处于版本控制之下的，就像你的<code>.gitignore</code>文件一样。它跟项目里的其他文件一样可以被推送和拉取。这是其他克隆此项目的人获知子模块项目来源的途径。</p>
<p><code>git status</code>的输出里所列的另一项目是 rack 。如果你运行在那上面运行<code>git diff</code>，会发现一些有趣的东西：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git diff --cached rack</div><div class="line">diff --git a/rack b/rack</div><div class="line">new file mode <span class="number">160000</span></div><div class="line">index <span class="number">0000000</span>..<span class="number">08</span>d709f</div><div class="line">--- /dev/null</div><div class="line">+++ b/rack</div><div class="line">@@ -<span class="number">0</span>,<span class="number">0</span> +<span class="number">1</span> @@</div><div class="line">+Subproject commit <span class="number">08</span>d709f78b8c5b0fbeb7821e37fa53e69afcf433</div></pre></td></tr></table></figure>
<p>尽管rack是你工作目录里的子目录，但 Git 把它视作一个子模块，当你不在那个目录里时并不记录它的内容。取而代之的是，Git 将它记录成来自那个仓库的一个特殊的提交。当你在那个子目录里修改并提交时，子项目会通知那里的 HEAD 已经发生变更并记录你当前正在工作的那个提交；通过那样的方法，当其他人克隆此项目，他们可以重新创建一致的环境。</p>
<p>这是关于子模块的重要一点：你记录他们当前确切所处的提交。你不能记录一个子模块的master或者其他的符号引用。</p>
<p>当你提交时，会看到类似下面的：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git commit -m <span class="string">'first commit with submodule rack'</span></div><div class="line">[master <span class="number">0550271</span>] first commit with submodule rack</div><div class="line"> <span class="number">2</span> files changed, <span class="number">4</span> insertions(+), <span class="number">0</span> deletions(-)</div><div class="line"> create mode <span class="number">100644</span> .gitmodules</div><div class="line"> create mode <span class="number">160000</span> rack</div></pre></td></tr></table></figure>
<p>注意 rack 条目的 160000 模式。这在Git中是一个特殊模式，基本意思是你将一个提交记录为一个目录项而不是子目录或者文件。</p>
<p>你可以将rack目录当作一个独立的项目，保持一个指向子目录的最新提交的指针然后反复地更新上层项目。所有的Git命令都在两个子目录里独立工作：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ git log -<span class="number">1</span></div><div class="line">commit <span class="number">0550271328</span>a0038865aad6331e620cd7238601bb</div><div class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</div><div class="line">Date:   Thu Apr <span class="number">9</span> <span class="number">09</span>:<span class="number">03</span>:<span class="number">56</span> <span class="number">2009</span> -<span class="number">0700</span></div><div class="line"></div><div class="line">    first commit with submodule rack</div><div class="line">$ cd rack/</div><div class="line">$ git log -<span class="number">1</span></div><div class="line">commit <span class="number">08</span>d709f78b8c5b0fbeb7821e37fa53e69afcf433</div><div class="line">Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;</div><div class="line">Date:   Wed Mar <span class="number">25</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">04</span> <span class="number">2009</span> +<span class="number">0100</span></div><div class="line"></div><div class="line">    Document version change</div></pre></td></tr></table></figure>
<h4 id="克隆一个带子模块的项目"><a href="#克隆一个带子模块的项目" class="headerlink" title="克隆一个带子模块的项目"></a>克隆一个带子模块的项目</h4><p>这里你将克隆一个带子模块的项目。当你接收到这样一个项目，你将得到了包含子项目的目录，但里面没有文件：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ git clone git://github.com/schacon/myproject.git</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /opt/myproject/.git/</div><div class="line">remote: Counting objects: <span class="number">6</span>, done.</div><div class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">4</span>/<span class="number">4</span>), done.</div><div class="line">remote: Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</div><div class="line">Receiving objects: <span class="number">100</span>% (<span class="number">6</span>/<span class="number">6</span>), done.</div><div class="line">$ cd myproject</div><div class="line">$ ls -l</div><div class="line">total <span class="number">8</span></div><div class="line">-rw-r--r--  <span class="number">1</span> schacon  admin   <span class="number">3</span> Apr  <span class="number">9</span> <span class="number">09</span>:<span class="number">11</span> README</div><div class="line">drwxr-xr-x  <span class="number">2</span> schacon  admin  <span class="number">68</span> Apr  <span class="number">9</span> <span class="number">09</span>:<span class="number">11</span> rack</div><div class="line">$ ls rack/</div><div class="line">$</div></pre></td></tr></table></figure>
<p>rack目录存在了，但是是空的。你必须运行两个命令：<code>git submodule init</code>来初始化你的本地配置文件，<code>git submodule update</code>来从那个项目拉取所有数据并检出你上层项目里所列的合适的提交：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git submodule init</div><div class="line">Submodule <span class="string">'rack'</span> (git://github.com/chneukirchen/rack.git) registered <span class="keyword">for</span> path <span class="string">'rack'</span></div><div class="line">$ git submodule update</div><div class="line">Initialized empty Git repository <span class="keyword">in</span> /opt/myproject/rack/.git/</div><div class="line">remote: Counting objects: <span class="number">3181</span>, done.</div><div class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">1534</span>/<span class="number">1534</span>), done.</div><div class="line">remote: Total <span class="number">3181</span> (delta <span class="number">1951</span>), reused <span class="number">2623</span> (delta <span class="number">1603</span>)</div><div class="line">Receiving objects: <span class="number">100</span>% (<span class="number">3181</span>/<span class="number">3181</span>), <span class="number">675.42</span> KiB | <span class="number">173</span> KiB/s, done.</div><div class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">1951</span>/<span class="number">1951</span>), done.</div><div class="line">Submodule path <span class="string">'rack'</span>: checked out <span class="string">'08d709f78b8c5b0fbeb7821e37fa53e69afcf433'</span></div></pre></td></tr></table></figure>
<p>现在你的rack子目录就处于你先前提交的确切状态了。如果另外一个开发者变更了 rack 的代码并提交，你拉取那个引用然后归并之，将得到稍有点怪异的东西：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ git merge origin/master</div><div class="line">Updating <span class="number">0550271</span>..<span class="number">85</span>a3eee</div><div class="line">Fast forward</div><div class="line"> rack |    <span class="number">2</span> +-</div><div class="line"> <span class="number">1</span> files changed, <span class="number">1</span> insertions(+), <span class="number">1</span> deletions(-)</div><div class="line">[master*]$ git status</div><div class="line"><span class="comment"># On branch master</span></div><div class="line"><span class="comment"># Changed but not updated:</span></div><div class="line"><span class="comment">#   (use "git add &lt;file&gt;..." to update what will be committed)</span></div><div class="line"><span class="comment">#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment">#      modified:   rack</span></div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
<p>你归并来的仅仅上是一个指向你的子模块的指针；但是它并不更新你子模块目录里的代码，所以看起来你的工作目录处于一个临时状态：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git diff</div><div class="line">diff --git a/rack b/rack</div><div class="line">index <span class="number">6</span>c5e70b..<span class="number">08</span>d709f <span class="number">160000</span></div><div class="line">--- a/rack</div><div class="line">+++ b/rack</div><div class="line">@@ -<span class="number">1</span> +<span class="number">1</span> @@</div><div class="line">-Subproject commit <span class="number">6</span>c5e70b984a60b3cecd395edd5b48a7575bf58e0</div><div class="line">+Subproject commit <span class="number">08</span>d709f78b8c5b0fbeb7821e37fa53e69afcf433</div></pre></td></tr></table></figure>
<p>事情就是这样，因为你所拥有的子模块的指针并对应于子模块目录的真实状态。为了修复这一点，你必须再次运行<code>git submodule update</code>：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git submodule update</div><div class="line">remote: Counting objects: <span class="number">5</span>, done.</div><div class="line">remote: Compressing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</div><div class="line">remote: Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">2</span> (delta <span class="number">0</span>)</div><div class="line">Unpacking objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</div><div class="line">From git@github.com:schacon/rack</div><div class="line">   <span class="number">08</span>d709f..<span class="number">6</span>c5e70b  master     -&gt; origin/master</div><div class="line">Submodule path <span class="string">'rack'</span>: checked out <span class="string">'6c5e70b984a60b3cecd395edd5b48a7575bf58e0'</span></div></pre></td></tr></table></figure>
<p>每次你从主项目中拉取一个子模块的变更都必须这样做。看起来很怪但是管用。</p>
<p>一个常见问题是当开发者对子模块做了一个本地的变更但是并没有推送到公共服务器。然后他们提交了一个指向那个非公开状态的指针然后推送上层项目。当其他开发者试图运行<code>git submodule update</code>，那个子模块系统会找不到所引用的提交，因为它只存在于第一个开发者的系统中。如果发生那种情况，你会看到类似这样的错误：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git submodule update</div><div class="line">fatal: reference isn’t a tree: <span class="number">6</span>c5e70b984a60b3cecd395edd5b48a7575bf58e0</div><div class="line">Unable to checkout <span class="string">'6c5e70b984a60b3cecd395edd5ba7575bf58e0'</span> <span class="keyword">in</span> submodule path <span class="string">'rack'</span></div></pre></td></tr></table></figure>
<p>你不得不去查看谁最后变更了子模块</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git log -<span class="number">1</span> rack</div><div class="line">commit <span class="number">85</span>a3eee996800fcfa91e2119372dd4172bf76678</div><div class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</div><div class="line">Date:   Thu Apr <span class="number">9</span> <span class="number">09</span>:<span class="number">19</span>:<span class="number">14</span> <span class="number">2009</span> -<span class="number">0700</span></div><div class="line"></div><div class="line">    added a submodule reference I will never make public. hahahahaha!</div></pre></td></tr></table></figure>
<p>然后，你给那个家伙发电子邮件说他一通。</p>
<h2 id="自定义git"><a href="#自定义git" class="headerlink" title="自定义git"></a>自定义git</h2><h3 id="格式化与空白"><a href="#格式化与空白" class="headerlink" title="格式化与空白"></a>格式化与空白</h3><p>格式化与空白是许多开发人员在协作时，特别是在跨平台情况下，遇到的令人头疼的细小问题。由于编辑器的不同或者Windows程序员在跨平台项目中的文件行尾加入了回车换行符，一些细微的空格变化会不经意地进入大家合作的工作或提交的补丁中。不用怕，Git 的一些配置选项会帮助你解决这些问题。</p>
<h4 id="core-autocrlf"><a href="#core-autocrlf" class="headerlink" title="core.autocrlf"></a>core.autocrlf</h4><p>假如你正在Windows上写程序，又或者你正在和其他人合作，他们在Windows上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。这是因为Windows使用回车和换行两个字符来结束一行，而Mac和Linux只使用换行一个字符。虽然这是小问题，但它会极大地扰乱跨平台协作。</p>
<p>Git可以在你提交时自动地把行结束符CRLF转换成LF，而在签出代码时把LF转换成CRLF。用<code>core.autocrlf</code>来打开此项功能，如果是在Windows系统上，把它设置成true，这样当签出代码时，LF会被转换成CRLF：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global core.autocrlf true</div></pre></td></tr></table></figure>
<p>Linux或Mac系统使用LF作为行结束符，因此你不想 Git 在签出文件时进行自动的转换；当一个以CRLF为行结束符的文件不小心被引入时你肯定想进行修正，把<code>core.autocrlf</code>设置成input来告诉 Git 在提交时把CRLF转换成LF，签出时不转换：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global core.autocrlf input</div></pre></td></tr></table></figure>
<p>这样会在Windows系统上的签出文件中保留CRLF，会在Mac和Linux系统上，包括仓库中保留LF。</p>
<p>如果你是Windows程序员，且正在开发仅运行在Windows上的项目，可以设置false取消此功能，把回车符记录在库中：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global core.autocrlf false</div></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>git的基本使用就是这样。其中，特别注意fetch与pull的区别，merge与rebase区别。</p>
<p>fetch是将远程仓库的不同拉去到本地，但并不自动合并</p>
<p>pull是将远程仓库的不同拉去到本地，并自动合并</p>
<p>merge合并是基于合并的几个分支的不同产生一个新的提交，分支数目没有减少</p>
<p>rebase是在选定的基提交上做分支不同提交的重演。像是在使分支减少</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://www.open-open.com/lib/view/open1328069609436.html" target="_blank" rel="external">Git详解之一 Git起步</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069733264.html" target="_blank" rel="external">Git详解之二 Git基础</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069889514.html" target="_blank" rel="external">Git详解之三 Git分支</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328069988843.html" target="_blank" rel="external">Git详解之四 服务器上的Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070090108.html" target="_blank" rel="external">Git详解之五 分布式Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070367499.html" target="_blank" rel="external">Git详解之六 Git工具</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070404827.html" target="_blank" rel="external">Git详解之七 自定义Git</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070454218.html" target="_blank" rel="external">Git详解之八 Git与其他系统</a></li>
<li><a href="http://www.open-open.com/lib/view/open1328070620202.html" target="_blank" rel="external">Git详解之九 Git内部原理</a></li>
</ul>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center">
    <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechat.png" alt="xin053 WeChat Pay">
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.png" alt="xin053 Alipay">
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Git/" rel="tag">#Git</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/11/VS Code搭建Python开发环境/" rel="next" title="VS Code搭建Python开发环境">
                <i class="fa fa-chevron-left"></i> VS Code搭建Python开发环境
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/30/venv创建Python虚拟环境/" rel="prev" title="venv创建Python虚拟环境">
                venv创建Python虚拟环境 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/me.jpg" alt="xin053">
          <p class="site-author-name" itemprop="name">xin053</p>
          <p class="site-description motion-element" itemprop="description">正在用Windbg调试正在调试正在反汇编Windbg的IDA的OD...</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">55</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xin053" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/xin053" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/xin053" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/zhouzixin053" target="_blank" title="csdn">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  csdn
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://bbs.pediy.com/" title="看雪" target="_blank">看雪</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.geeklzh.com/" title="怪咖家园" target="_blank">怪咖家园</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.csdh.pub/" title="CS_DH" target="_blank">CS_DH</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://dendise7engithub.github.io/" title="Dendionk" target="_blank">Dendionk</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://cyang.tech/" title="cyang" target="_blank">cyang</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#git介绍"><span class="nav-number">1.</span> <span class="nav-text">git介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的三种状态"><span class="nav-number">2.</span> <span class="nav-text">文件的三种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的两种状态"><span class="nav-number">3.</span> <span class="nav-text">文件的两种状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检查当前文件状态"><span class="nav-number">4.</span> <span class="nav-text">检查当前文件状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gitignore文件"><span class="nav-number">5.</span> <span class="nav-text">.gitignore文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#差异查看"><span class="nav-number">6.</span> <span class="nav-text">差异查看</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#撤消操作"><span class="nav-number">7.</span> <span class="nav-text">撤消操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#修改最后一次提交"><span class="nav-number">7.1.</span> <span class="nav-text">修改最后一次提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消已经暂存的文件"><span class="nav-number">7.2.</span> <span class="nav-text">取消已经暂存的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消对文件的修改"><span class="nav-number">7.3.</span> <span class="nav-text">取消对文件的修改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#远程仓库"><span class="nav-number">8.</span> <span class="nav-text">远程仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加远程仓库"><span class="nav-number">8.1.</span> <span class="nav-text">添加远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从远程仓库抓取数据"><span class="nav-number">8.2.</span> <span class="nav-text">从远程仓库抓取数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送数据到远程仓库"><span class="nav-number">8.3.</span> <span class="nav-text">推送数据到远程仓库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程仓库的删除和重命名"><span class="nav-number">8.4.</span> <span class="nav-text">远程仓库的删除和重命名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标签"><span class="nav-number">9.</span> <span class="nav-text">标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#列显已有的标签"><span class="nav-number">9.1.</span> <span class="nav-text">列显已有的标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新建标签"><span class="nav-number">9.2.</span> <span class="nav-text">新建标签</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#含附注的标签"><span class="nav-number">9.2.1.</span> <span class="nav-text">含附注的标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级标签"><span class="nav-number">9.2.2.</span> <span class="nav-text">轻量级标签</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示标签内容"><span class="nav-number">9.3.</span> <span class="nav-text">显示标签内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#签署标签"><span class="nav-number">9.4.</span> <span class="nav-text">签署标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#验证标签"><span class="nav-number">9.5.</span> <span class="nav-text">验证标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后期加注标签"><span class="nav-number">9.6.</span> <span class="nav-text">后期加注标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分享标签"><span class="nav-number">9.7.</span> <span class="nav-text">分享标签</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-分支"><span class="nav-number">10.</span> <span class="nav-text">Git 分支</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#何谓分支"><span class="nav-number">10.1.</span> <span class="nav-text">何谓分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支的新建与合并"><span class="nav-number">10.2.</span> <span class="nav-text">分支的新建与合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支的新建与切换"><span class="nav-number">10.3.</span> <span class="nav-text">分支的新建与切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支的合并"><span class="nav-number">10.4.</span> <span class="nav-text">分支的合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#遇到冲突时的分支合并"><span class="nav-number">10.5.</span> <span class="nav-text">遇到冲突时的分支合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#远程分支"><span class="nav-number">10.6.</span> <span class="nav-text">远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送本地分支"><span class="nav-number">10.7.</span> <span class="nav-text">推送本地分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跟踪远程分支"><span class="nav-number">10.8.</span> <span class="nav-text">跟踪远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除远程分支"><span class="nav-number">10.9.</span> <span class="nav-text">删除远程分支</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分支的衍合"><span class="nav-number">10.10.</span> <span class="nav-text">分支的衍合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的衍合操作"><span class="nav-number">10.10.1.</span> <span class="nav-text">基本的衍合操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有趣的衍合"><span class="nav-number">10.10.2.</span> <span class="nav-text">有趣的衍合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#衍合的风险"><span class="nav-number">10.10.3.</span> <span class="nav-text">衍合的风险</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器上的git"><span class="nav-number">11.</span> <span class="nav-text">服务器上的git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#协议"><span class="nav-number">11.1.</span> <span class="nav-text">协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SSH-协议"><span class="nav-number">11.1.1.</span> <span class="nav-text">SSH 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点"><span class="nav-number">11.1.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点"><span class="nav-number">11.1.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-协议"><span class="nav-number">11.1.2.</span> <span class="nav-text">Git 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-1"><span class="nav-number">11.1.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-1"><span class="nav-number">11.1.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-S-协议"><span class="nav-number">11.1.3.</span> <span class="nav-text">HTTP/S 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点-2"><span class="nav-number">11.1.3.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点-2"><span class="nav-number">11.1.3.2.</span> <span class="nav-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式git"><span class="nav-number">12.</span> <span class="nav-text">分布式git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#提交指南"><span class="nav-number">12.1.</span> <span class="nav-text">提交指南</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有的小型团队"><span class="nav-number">12.2.</span> <span class="nav-text">私有的小型团队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#私有团队间协作"><span class="nav-number">12.3.</span> <span class="nav-text">私有团队间协作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公开的小型项目"><span class="nav-number">12.4.</span> <span class="nav-text">公开的小型项目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#git工具"><span class="nav-number">13.</span> <span class="nav-text">git工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#祖先引用"><span class="nav-number">13.1.</span> <span class="nav-text">祖先引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#储藏（Stashing）"><span class="nav-number">13.2.</span> <span class="nav-text">储藏（Stashing）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#储藏你的工作"><span class="nav-number">13.2.1.</span> <span class="nav-text">储藏你的工作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子模块"><span class="nav-number">13.3.</span> <span class="nav-text">子模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子模块初步"><span class="nav-number">13.3.1.</span> <span class="nav-text">子模块初步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#克隆一个带子模块的项目"><span class="nav-number">13.3.2.</span> <span class="nav-text">克隆一个带子模块的项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义git"><span class="nav-number">14.</span> <span class="nav-text">自定义git</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化与空白"><span class="nav-number">14.1.</span> <span class="nav-text">格式化与空白</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#core-autocrlf"><span class="nav-number">14.1.1.</span> <span class="nav-text">core.autocrlf</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结语"><span class="nav-number">15.</span> <span class="nav-text">结语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参考文档"><span class="nav-number">15.1.</span> <span class="nav-text">参考文档</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xin053</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'xin053';
      var disqus_identifier = '2016/06/18/Git使用详解/';
      var disqus_title = "Git使用详解";
      var disqus_url = 'https://xin053.github.io/2016/06/18/Git使用详解/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>